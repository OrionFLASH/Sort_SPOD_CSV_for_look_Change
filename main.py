#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Программа для сортировки CSV файлов
Сортирует строки по заданным полям с сохранением исходного форматирования
Обеспечивает одинаковую сортировку для двух файлов по одинаковым полям

Основные возможности:
- Автоматическое определение типов полей (текст, число, дата)
- Сортировка по нескольким полям с заданным порядком
- Сохранение исходного форматирования CSV файлов
- Логирование операций на двух уровнях (INFO и DEBUG)
- Обработка общих полей между файлами
- Гибкая настройка параметров сортировки

Технические особенности:
- Поддержка различных разделителей CSV (запятая, точка с запятой, табуляция)
- Автоматическое создание рабочей структуры папок
- Обработка ошибок с продолжением работы
- Сохранение исходного форматирования (кавычки, экранирование, пробелы)
- Универсальный парсер дат для различных форматов

Автор: Система автоматической генерации кода
Версия: 1.0
Дата создания: 2025
"""

# =============================================================================
# ИМПОРТ БИБЛИОТЕК
# =============================================================================
# В этом разделе импортируются все необходимые библиотеки Python
# 
# Стандартные библиотеки Python (входят в базовую установку):
# - os, sys: работа с операционной системой и системными параметрами
# - csv: чтение и запись CSV файлов
# - logging: система логирования для отладки и мониторинга
# - datetime: работа с датами и временем
# - pathlib: современная работа с путями файловой системы
# - typing: типизация для лучшей читаемости кода
# 
# Сторонние библиотеки (требуют установки через pip):
# - pandas: мощная библиотека для работы с данными
# - dateutil: универсальный парсер дат различных форматов

# Импортируем стандартные библиотеки Python
# Эти библиотеки входят в базовую установку Python, дополнительная установка не требуется
import os                    # Для работы с операционной системой (создание папок, проверка файлов)
import sys                   # Для системных параметров и аргументов командной строки
import csv                   # Для чтения CSV файлов (парсинг заголовков и данных)
import logging              # Для логирования операций на разных уровнях (INFO, DEBUG, ERROR)
import argparse             # Для парсинга аргументов командной строки (если понадобится)
from datetime import datetime  # Для работы с датами и временем (определение типа поля date)
from pathlib import Path    # Для работы с путями файловой системы (создание папок, формирование путей)
from typing import List, Dict, Any, Union, Set  # Для типизации данных (указание типов переменных)

# os - работа с операционной системой
# - Создание и удаление папок
# - Проверка существования файлов
# - Получение информации о системе

# sys - системные параметры Python
# - Аргументы командной строки
# - Информация о версии Python
# - Системные пути

# csv - работа с CSV файлами
# - Чтение и запись CSV данных
# - Обработка различных разделителей
# - Корректная работа с кавычками и экранированием

# logging - система логирования
# - Запись сообщений разных уровней
# - Вывод в файл и консоль
# - Форматирование логов с временными метками

# datetime - работа с датами и временем
# - Представление дат в программе
# - Сравнение дат для сортировки
# - Работа с временными зонами

# pathlib - современная работа с путями
# - Создание и объединение путей
# - Проверка существования файлов
# - Кроссплатформенная совместимость

# typing - типизация данных
# - Указание типов переменных и функций
# - Улучшение читаемости кода
# - Поддержка в современных IDE

# Импортируем сторонние библиотеки
# Эти библиотеки НЕ входят в стандартную установку Python
# Установите их командой: pip install -r requirements.txt
import pandas as pd         # Для работы с данными (если понадобится для сложной обработки)
from dateutil import parser as date_parser  # Для парсинга дат (автоматическое определение формата даты)

# pandas - мощная библиотека для анализа данных
# - Поддержка различных форматов файлов (CSV, Excel, JSON)
# - Продвинутая обработка и анализ данных
# - В данной программе используется как резервный вариант

# dateutil.parser - универсальный парсер дат
# - Автоматически определяет формат даты
# - Поддерживает множество форматов: DD.MM.YYYY, YYYY-MM-DD, MM/DD/YYYY
# - Обрабатывает различные разделители и локали


# =============================================================================
# КОНФИГУРАЦИЯ ПРОГРАММЫ
# =============================================================================
# В этом разделе настраиваются все основные параметры работы программы
# Измените эти значения под ваши нужды
# 
# ВАЖНО: После изменения конфигурации перезапустите программу
# Все настройки применяются только при запуске
# 
# Структура конфигурации:
# 1. Базовые пути - где программа ищет и сохраняет файлы
# 2. Настройки логирования - как вести логи
# 3. Имена файлов - какие файлы обрабатывать
# 4. Настройки сортировки - как сортировать данные
# 
# Рекомендации по настройке:
# - Сначала настройте базовые пути (BASE_PATH)
# - Затем укажите имена файлов для обработки
# - Настройте параметры сортировки под ваши данные
# - Проверьте настройки логирования

# Базовые пути - основная рабочая директория и подпапки
# Программа автоматически создаст эти папки при первом запуске
BASE_PATH = '/Users/orionflash/Desktop/MyProject/SORT_CSV_SPOD/WORK'  # Главная папка для работы программы
INPUT_SUBFOLDER = 'INPUT'      # Папка, где лежат исходные CSV файлы для обработки
OUTPUT_SUBFOLDER = 'OUTPUT'    # Папка, куда будут сохранены отсортированные файлы
LOGS_SUBFOLDER = 'LOGS'        # Папка для хранения файлов логов программы

# Структура создаваемых папок:
# WORK/
# ├── INPUT/     ← сюда поместите ваши CSV файлы для обработки
# ├── OUTPUT/    ← отсюда забирайте отсортированные файлы
# └── LOGS/      ← здесь будут файлы логов для отладки

# Настройки логирования - имя файла для записи логов (без расширения .log)
LOG_FILENAME = 'csv_sorter'    # Файл будет называться csv_sorter.log

# Система логирования создаст два потока:
# 1. Файл: WORK/LOGS/csv_sorter.log (все сообщения, включая DEBUG)
# 2. Консоль: только INFO, WARNING, ERROR (без отладочной информации)
# 
# Уровни логирования:
# - DEBUG: детальная информация для отладки (только в файл)
# - INFO: основная информация о работе программы (файл + консоль)
# - WARNING: предупреждения (файл + консоль)
# - ERROR: ошибки (файл + консоль)

# Имена входных файлов (БЕЗ расширения .csv)
# Программа автоматически добавит расширение .csv к каждому имени
# 
# ВАЖНО: 
# - Указывайте имена файлов БЕЗ расширения .csv
# - Файлы должны находиться в папке WORK/INPUT/
# - Программа обработает только файлы, указанные в этом списке
# - Порядок файлов в списке определяет порядок обработки
INPUT_FILES = [
    'REWARD (PROM) 2025-08-07 — копия(Клара)',  # Первый файл для обработки
    'REWARD (PROM) 2025-07-24 v1'               # Второй файл для обработки
]

# Примеры правильных имен:
# - 'data' → программа ищет файл 'data.csv'
# - 'users_2024' → программа ищет файл 'users_2024.csv'
# - 'REWARD (PROM) 2025-08-07' → программа ищет файл 'REWARD (PROM) 2025-08-07.csv'

# Настройки сортировки - основной конфигурационный блок
# Здесь настраивается, как именно будут сортироваться данные в CSV файлах
SORT_CONFIG = {
    'delimiter': ';',  # Разделитель полей в CSV файле (точка с запятой для ваших файлов)
                       # Можно использовать: ',' (запятая), ';' (точка с запятой), '\t' (табуляция)
                       # 
                       # Как определить разделитель:
                       # - Откройте CSV файл в текстовом редакторе
                       # - Посмотрите, чем разделены поля: запятая, точка с запятой или табуляция
                       # - Укажите соответствующий символ здесь
    
    'fields': [        # Список полей для сортировки (можно сортировать по нескольким полям)
        {
            'name': 'REWARD_CODE',      # Имя поля для сортировки (должно точно совпадать с заголовком в CSV)
            'type': 'text',            # Тип поля: 'auto', 'text', 'number', 'date'
                                       # 'auto' - автоматическое определение типа (рекомендуется)
                                       # 'text' - текстовое поле (сортировка по алфавиту)
                                       # 'number' - числовое поле (сортировка по значению)
                                       # 'date' - поле даты (сортировка по времени)
            'order': 'asc'             # Порядок сортировки: 'asc' (возрастание), 'desc' (убывание)
        }
        # Можно добавить дополнительные поля для сортировки, раскомментировав блоки ниже:
        # {
        #     'name': 'salary',          # Имя поля для сортировки
        #     'type': 'number',          # Тип поля: 'auto', 'text', 'number', 'date'
        #     'order': 'desc'            # Порядок сортировки: 'asc' (возрастание), 'desc' (убывание)
        # },
        # {
        #     'name': 'hire_date',       # Имя поля для сортировки
        #     'type': 'date',            # Тип поля: 'auto', 'text', 'number', 'date'
        #     'order': 'asc'             # Порядок сортировки: 'asc' (возрастание), 'desc' (убывание)
        # }
    ],
    
    'order': 'asc'  # Общий порядок сортировки (если не указан для конкретного поля)
                    # Используется как значение по умолчанию для всех полей
                    # 
                    # Приоритет порядка сортировки:
                    # 1. Порядок, указанный для конкретного поля (если есть)
                    # 2. Общий порядок из этой переменной (если для поля не указан)
}

# Типы полей и их особенности:
# - 'auto': программа сама определяет тип по содержимому (рекомендуется)
# - 'text': сортировка по алфавиту (A→Z, А→Я)
# - 'number': сортировка по числовому значению (1→9, 1.5→2.0)
# - 'date': сортировка по времени (старые→новые или новые→старые)
# 
# Порядок сортировки:
# - 'asc': возрастание (A→Z, 1→9, старые→новые)
# - 'desc': убывание (Z→A, 9→1, новые→старые)

# =============================================================================
# ПРИМЕРЫ КОНФИГУРАЦИЙ ДЛЯ РАЗНЫХ СЛУЧАЕВ
# =============================================================================
# Эти примеры показывают, как можно настроить сортировку для разных типов данных
# Скопируйте нужный пример в SORT_CONFIG выше, изменив под ваши поля
# 
# Каждый пример демонстрирует различные сценарии использования:
# - Сортировка по одному полю
# - Сортировка по нескольким полям
# - Разные типы данных (текст, числа, даты)
# - Разные порядки сортировки (возрастание/убывание)
# 
# Как использовать примеры:
# 1. Выберите подходящий пример под ваши задачи
# 2. Скопируйте его в переменную SORT_CONFIG выше
# 3. Измените имена полей на те, что есть в ваших CSV файлах
# 4. Настройте типы полей и порядок сортировки
# 5. Перезапустите программу

# Пример 1: Сортировка по одному числовому полю в порядке убывания
# Подходит для: рейтингов, цен, количества, где нужно показать лучшие результаты первыми
# 
# Типичные случаи использования:
# - Сортировка товаров по цене (от дорогих к дешевым)
# - Сортировка сотрудников по зарплате (от высоких к низким)
# - Сортировка продуктов по рейтингу (от лучших к худшим)
# 
# Особенности конфигурации:
# - delimiter: ',' - стандартный разделитель для большинства CSV файлов
# - fields: одно поле для простой сортировки
# - type: 'number' - явно указываем числовой тип для корректной сортировки
# - order: 'desc' - убывание для показа лучших результатов первыми
SORT_CONFIG_NUMERIC_DESC = {
    'delimiter': ',',        # Разделитель - запятая
    'fields': [
        {
            'name': 'price',     # Имя поля - цена
            'type': 'number',    # Тип - число
            'order': 'desc'      # Порядок - убывание (от большей к меньшей)
        }
    ],
    'order': 'desc'  # Общий порядок тоже убывание
}

# Пример 2: Сортировка по нескольким полям (сложная сортировка)
# Подходит для: сначала по отделу, потом по зарплате, потом по дате приема
# 
# Типичные случаи использования:
# - Сортировка сотрудников: отдел → зарплата → дата приема
# - Сортировка товаров: категория → цена → дата добавления
# - Сортировка заказов: статус → сумма → дата создания
# 
# Приоритет сортировки: первое поле имеет наивысший приоритет
# 
# Особенности конфигурации:
# - delimiter: ';' - европейский разделитель (точка с запятой)
# - fields: три поля для сложной сортировки
# - Разные типы данных: текст, число, дата
# - Разные порядки сортировки для разных полей
# 
# Логика сортировки:
# 1. Сначала по отделу (А-Я)
# 2. Внутри отдела по зарплате (от высокой к низкой)
# 3. При одинаковой зарплате по дате приема (от старых к новым)
SORT_CONFIG_MULTI_FIELD = {
    'delimiter': ';',        # Разделитель - точка с запятой
    'fields': [
        {
            'name': 'department',  # Первое поле - отдел
            'type': 'text',        # Тип - текст
            'order': 'asc'         # Порядок - возрастание (А-Я)
        },
        {
            'name': 'salary',      # Второе поле - зарплата
            'type': 'number',      # Тип - число
            'order': 'desc'        # Порядок - убывание (от большей к меньшей)
        },
        {
            'name': 'hire_date',   # Третье поле - дата приема
            'type': 'date',        # Тип - дата
            'order': 'asc'         # Порядок - возрастание (от старых к новым)
        }
    ],
    'order': 'asc'  # Общий порядок - возрастание
}

# Пример 3: Сортировка только по дате в порядке убывания
# Подходит для: новостей, событий, где нужно показать самые свежие первыми
# 
# Типичные случаи использования:
# - Сортировка новостей по дате публикации (новые первыми)
# - Сортировка событий по дате проведения (ближайшие первыми)
# - Сортировка документов по дате создания (последние первыми)
# 
# Автоматическое определение формата даты поддерживает большинство стандартных форматов
# 
# Особенности конфигурации:
# - delimiter: ',' - стандартный разделитель
# - fields: одно поле даты для простой сортировки
# - type: 'date' - явно указываем тип даты
# - order: 'desc' - убывание для показа новых записей первыми
# 
# Поддерживаемые форматы дат:
# - DD.MM.YYYY, DD/MM/YYYY
# - YYYY-MM-DD, YYYY/MM/DD
# - MM/DD/YYYY (американский формат)
# - Другие стандартные форматы
SORT_CONFIG_DATE = {
    'delimiter': ',',        # Разделитель - запятая
    'fields': [
        {
            'name': 'date',        # Имя поля - дата
            'type': 'date',        # Тип - дата
            'order': 'desc'        # Порядок - убывание (от новых к старым)
        }
    ],
    'order': 'desc'  # Общий порядок тоже убывание
}


# =============================================================================
# ОСНОВНОЙ КЛАСС ДЛЯ СОРТИРОВКИ CSV ФАЙЛОВ
# =============================================================================
# Этот класс содержит всю логику работы с CSV файлами:
# - Чтение и парсинг CSV файлов
# - Определение типов полей
# - Сортировка данных по заданным критериям
# - Сохранение результатов с сохранением форматирования
# - Логирование всех операций
# 
# Архитектура класса:
# - Инициализация: настройка логирования, создание папок, анализ файлов
# - Анализ: определение общих полей между файлами
# - Обработка: сортировка каждого файла по заданным критериям
# - Логирование: запись всех операций для отладки и мониторинга
# 
# Принципы работы:
# - Обработка ошибок: программа продолжает работу даже при ошибках в отдельных файлах
# - Безопасность: проверка существования файлов и корректности данных
# - Логирование: подробная запись всех операций для отладки
# - Гибкость: поддержка различных форматов CSV и типов данных
# 
# Структура методов:
# - __init__: инициализация и настройка
# - setup_logging: настройка системы логирования
# - create_directories: создание рабочей структуры папок
# - get_common_sort_fields: анализ общих полей между файлами
# - detect_field_type: автоматическое определение типа поля
# - sort_value: преобразование значений для сортировки
# - sort_csv_file: основная логика сортировки одного файла
# - process_files: координация обработки всех файлов

class CSVSorter:
    """
    Главный класс для сортировки CSV файлов
    
    Основные функции:
    - Анализ структуры CSV файлов
    - Определение общих полей между файлами
    - Автоматическое определение типов данных
    - Сортировка по заданным полям
    - Сохранение без изменения форматирования
    
    Ключевые особенности:
    - Автоматическое создание необходимых папок
    - Двухуровневое логирование (INFO в консоль, DEBUG в файл)
    - Обработка ошибок с продолжением работы
    - Поддержка различных форматов CSV (разные разделители)
    - Сохранение исходного форматирования файлов
    
    Атрибуты экземпляра:
    - config: словарь с конфигурацией программы
    - logger: настроенный логгер для записи сообщений
    - common_sort_fields: список общих полей для сортировки
    
    Методы:
    - Публичные: process_files() - основной метод для запуска обработки
    - Приватные: все остальные методы для внутренней логики
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Инициализация сортировщика CSV файлов
        
        При создании объекта класса происходит:
        1. Сохранение конфигурации в экземпляре класса
        2. Настройка системы логирования (файл + консоль)
        3. Создание необходимых папок (INPUT, OUTPUT, LOGS)
        4. Анализ входных файлов для определения общих полей
        
        Последовательность инициализации:
        - Сначала сохраняется конфигурация
        - Затем настраивается логирование (нужно для записи логов)
        - Создаются папки (нужны для работы программы)
        - Анализируются файлы (определяются поля для сортировки)
        
        Args:
            config: Словарь с конфигурацией программы, содержащий:
                   - base_path: базовая рабочая папка
                   - input_subfolder: папка для входных файлов
                   - output_subfolder: папка для результатов
                   - logs_subfolder: папка для логов
                   - log_filename: имя файла логов
                   - input_files: список файлов для обработки
                   - sort_config: настройки сортировки
        """
        # Сохраняем конфигурацию в экземпляре класса для использования во всех методах
        self.config = config
        
        # Настраиваем систему логирования (создаем папку для логов, настраиваем уровни)
        self.setup_logging()
        
        # Получаем логгер для текущего класса (для записи информационных сообщений)
        self.logger = logging.getLogger(__name__)
        
        # Создаем необходимые директории для работы (INPUT, OUTPUT, LOGS)
        self.create_directories()
        
        # Определяем общие поля для сортировки между всеми файлами
        # Это важно для обеспечения одинаковой сортировки в разных файлах
        self.common_sort_fields = self.get_common_sort_fields()
        
    def setup_logging(self):
        """
        Настройка системы логирования на двух уровнях: INFO и DEBUG
        
        Создает два потока логирования:
        1. Файловый - записывает ВСЕ сообщения (DEBUG + INFO + WARNING + ERROR) в файл
        2. Консольный - выводит только важные сообщения (INFO + WARNING + ERROR) в терминал
        
        Структура логов:
        - Время выполнения (точность до миллисекунд)
        - Имя модуля/класса (для идентификации источника)
        - Уровень сообщения (DEBUG, INFO, WARNING, ERROR)
        - Текст сообщения (описание операции или ошибки)
        
        Преимущества двухуровневого логирования:
        - Консоль: только важная информация (меньше "шума")
        - Файл: полная детализация для отладки
        - Разные уровни для разных целей
        
        Формат времени: YYYY-MM-DD HH:MM:SS,mmm
        """
        
        # Создаем директорию для логов внутри рабочей папки
        # Например: /Users/.../WORK/LOGS/
        log_dir = Path(self.config['base_path']) / self.config['logs_subfolder']
        log_dir.mkdir(parents=True, exist_ok=True)  # Создаем папку, если её нет (parents=True создает родительские папки)
        
        # Формируем полный путь к файлу логов
        # Например: /Users/.../WORK/LOGS/csv_sorter.log
        log_file = log_dir / f"{self.config['log_filename']}.log"
        
        # Создаем форматтер для логов с временными метками
        # Формат: 2025-08-13 13:53:16,370 - __main__ - INFO - Сообщение
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Создаем файловый хендлер для записи логов в файл (уровень DEBUG)
        # DEBUG включает все сообщения: DEBUG, INFO, WARNING, ERROR, CRITICAL
        file_handler = logging.FileHandler(log_file, encoding='utf-8')  # UTF-8 для корректного отображения русского текста
        file_handler.setLevel(logging.DEBUG)  # Записываем ВСЕ логи в файл (максимальная детализация)
        file_handler.setFormatter(formatter)  # Применяем форматирование с временными метками
        
        # Создаем консольный хендлер для вывода в терминал (уровень INFO)
        # INFO включает только важные сообщения: INFO, WARNING, ERROR, CRITICAL (без DEBUG)
        console_handler = logging.StreamHandler()  # Вывод в стандартный поток (терминал)
        console_handler.setLevel(logging.INFO)  # В консоль только важные сообщения (меньше "шума")
        console_handler.setFormatter(formatter)  # Применяем то же форматирование
        
        # Настраиваем корневой логгер для всей программы
        root_logger = logging.getLogger()  # Получаем корневой логгер
        root_logger.setLevel(logging.DEBUG)  # Устанавливаем минимальный уровень для корневого логгера
        root_logger.addHandler(file_handler)  # Добавляем файловый хендлер (все сообщения в файл)
        root_logger.addHandler(console_handler)  # Добавляем консольный хендлер (важные сообщения в терминал)
        
        # Записываем информацию о настройке логирования
        # Используем logging.info, так как self.logger еще не создан
        logging.info(f"Логирование настроено. Файл логов: {log_file}")
        
    def create_directories(self):
        """
        Создание необходимых директорий для работы программы
        
        Создает структуру папок:
        WORK/
        ├── INPUT/     - для исходных CSV файлов
        ├── OUTPUT/    - для отсортированных файлов
        └── LOGS/      - для файлов логов (создается в setup_logging)
        
        Особенности создания:
        - parents=True: создает родительские папки, если их нет
        - exist_ok=True: не вызывает ошибку, если папка уже существует
        - Автоматическое создание всей структуры папок
        
        Безопасность:
        - Проверяет существование папок перед созданием
        - Не перезаписывает существующие папки
        - Создает папки с правами по умолчанию
        
        Логирование:
        - Записывает информацию о созданных директориях
        - Помогает отследить, где программа ищет и сохраняет файлы
        """
        
        # Получаем базовый путь из конфигурации
        # Например: /Users/orionflash/Desktop/MyProject/SORT_CSV_SPOD/WORK
        base_path = Path(self.config['base_path'])
        
        # Формируем пути к папкам INPUT и OUTPUT
        # Например: /Users/.../WORK/INPUT и /Users/.../WORK/OUTPUT
        input_dir = base_path / self.config['input_subfolder']   # Папка для входных файлов
        output_dir = base_path / self.config['output_subfolder'] # Папка для результатов
        
        # Создаем папки, если их нет
        # parents=True - создает родительские папки, если их нет
        # exist_ok=True - не вызывает ошибку, если папка уже существует
        input_dir.mkdir(parents=True, exist_ok=True)   # Создаем папку INPUT
        output_dir.mkdir(parents=True, exist_ok=True)  # Создаем папку OUTPUT
        
        # Записываем информацию о созданных директориях в лог
        # Это помогает отследить, где программа ищет и сохраняет файлы
        self.logger.info(f"Директории созданы: {input_dir}, {output_dir}")
        
    def get_common_sort_fields(self) -> List[Dict[str, Any]]:
        """
        Определяет общие поля для сортировки, которые присутствуют во всех файлах
        
        Этот метод критически важен для обеспечения одинаковой сортировки:
        - Читает заголовки всех CSV файлов
        - Находит пересечение (общие поля)
        - Фильтрует конфигурацию сортировки, оставляя только общие поля
        - Предотвращает ошибки при сортировке по несуществующим полям
        
        Логика работы:
        1. Читает заголовки каждого CSV файла
        2. Находит пересечение заголовков (поля, присутствующие во всех файлах)
        3. Фильтрует конфигурацию сортировки по общим полям
        4. Логирует найденные общие поля и предупреждения
        
        Безопасность:
        - Проверяет существование файлов перед чтением
        - Обрабатывает ошибки чтения отдельных файлов
        - Возвращает пустой список, если нет общих полей
        
        Returns:
            Список конфигураций полей для сортировки (только те, что есть во всех файлах)
            
        Пример:
        Файл 1: ['name', 'age', 'city']
        Файл 2: ['name', 'age', 'country']
        Общие поля: ['name', 'age']
        """
        
        # Формируем путь к папке с входными файлами
        base_path = Path(self.config['base_path'])
        input_dir = base_path / self.config['input_subfolder']
        
        # Словарь для хранения заголовков каждого файла
        # Ключ: имя файла, значение: множество заголовков (set для быстрого поиска)
        file_headers = {}
        
        # Проходим по всем файлам из конфигурации
        for filename in self.config['input_files']:
            # Формируем полный путь к CSV файлу, добавляя расширение .csv
            input_file = input_dir / f"{filename}.csv"
            
            # Проверяем существование файла перед попыткой чтения
            if input_file.exists():
                try:
                    # Открываем файл для чтения в UTF-8 кодировке
                    # newline='' - для корректной обработки разных типов переносов строк
                    with open(input_file, 'r', encoding='utf-8', newline='') as f:
                        # Создаем CSV reader с заданным разделителем (; или ,)
                        reader = csv.reader(f, delimiter=self.config['sort_config']['delimiter'])
                        # Читаем первую строку (заголовок) с помощью next()
                        header = next(reader)
                        # Сохраняем заголовки как множество для быстрого поиска
                        # set() позволяет быстро проверять принадлежность элемента
                        file_headers[filename] = set(header)
                        # Записываем отладочную информацию (видно только в файле логов)
                        self.logger.debug(f"Файл {filename}: заголовки {header}")
                        
                except Exception as e:
                    # В случае ошибки чтения файла (поврежден, нет прав доступа и т.д.)
                    self.logger.error(f"Ошибка чтения заголовков файла {filename}: {str(e)}")
                    file_headers[filename] = set()  # Пустое множество для этого файла
            else:
                # Если файл не существует, создаем пустое множество
                file_headers[filename] = set()
                
        # Находим пересечение заголовков всех файлов (общие поля)
        if len(file_headers) < 2:
            # Если файлов меньше двух, возвращаем исходную конфигурацию
            # Это может произойти, если файлы не найдены или повреждены
            self.logger.warning("Недостаточно файлов для определения общих полей")
            return self.config['sort_config']['fields']
            
        # Находим общие заголовки во всех файлах с помощью set.intersection()
        # *file_headers.values() распаковывает все множества заголовков
        common_headers = set.intersection(*file_headers.values())
        self.logger.info(f"Общие заголовки во всех файлах: {sorted(common_headers)}")
        
        # Фильтруем поля сортировки, оставляя только те, что есть во всех файлах
        common_sort_fields = []
        for field_config in self.config['sort_config']['fields']:
            field_name = field_config['name']  # Имя поля из конфигурации сортировки
            
            if field_name in common_headers:
                # Если поле есть во всех файлах, добавляем его для сортировки
                common_sort_fields.append(field_config)
                self.logger.info(f"Поле '{field_name}' будет использоваться для сортировки")
            else:
                # Если поля нет в одном из файлов, пропускаем его
                # Это предотвращает ошибки при сортировке
                self.logger.warning(f"Поле '{field_name}' отсутствует в одном или нескольких файлах и будет пропущено")
                
        # Проверяем, что остались поля для сортировки
        if not common_sort_fields:
            # Если нет общих полей, сортировка невозможна
            self.logger.error("Нет общих полей для сортировки!")
            return []
            
        # Записываем итоговый список полей для сортировки
        self.logger.info(f"Итоговые поля для сортировки: {[f['name'] for f in common_sort_fields]}")
        return common_sort_fields
        
    def detect_field_type(self, sample_values: List[str]) -> str:
        """
        Автоматическое определение типа поля на основе образцов значений
        
        Этот метод анализирует содержимое поля и определяет его тип:
        - text: текстовые данные (сортировка по алфавиту)
        - number: числовые данные (сортировка по значению)
        - date: даты (сортировка по времени)
        
        Алгоритм определения:
        1. Если 80%+ значений - числа → поле числовое
        2. Если 80%+ значений - даты → поле даты
        3. Иначе → поле текстовое
        
        Порог 80% позволяет игнорировать случайные текстовые значения
        в числовых полях (например, "N/A" или пустые строки).
        
        Args:
            sample_values: Список образцов значений из поля (первые 100 строк)
                         Используются первые 100 строк для быстрого анализа
                         
        Returns:
            Тип поля: 'text', 'number', 'date'
            
        Примеры определения:
        - ['1', '2', '3', 'abc'] → 'number' (75% чисел, но есть текст)
        - ['2023-01-01', '2023-01-02', 'invalid'] → 'date' (67% дат, но есть текст)
        - ['hello', 'world', 'test'] → 'text' (100% текст)
        """
        
        # Если нет образцов, считаем поле текстовым по умолчанию
        if not sample_values:
            return 'text'
            
        # Убираем пустые значения и пробелы, оставляем только непустые строки
        # strip() убирает пробелы в начале и конце строки
        non_empty = [v.strip() for v in sample_values if v.strip()]
        if not non_empty:
            return 'text'  # Если все значения пустые, считаем текстовым
            
        # Проверяем, сколько значений можно преобразовать в числа
        number_count = 0
        for value in non_empty:
            try:
                # Пытаемся преобразовать в число, заменяя запятую на точку
                # Это нужно для европейского формата чисел (1,5 → 1.5)
                float(value.replace(',', '.'))
                number_count += 1
            except ValueError:
                # Если не получилось преобразовать в число, пропускаем
                # ValueError возникает при попытке преобразовать "abc" в число
                pass
                
        # Если больше 80% значений - числа, считаем поле числовым
        # Порог 80% позволяет игнорировать случайные текстовые значения
        if number_count / len(non_empty) > 0.8:
            return 'number'
            
        # Проверяем, сколько значений можно преобразовать в даты
        date_count = 0
        for value in non_empty:
            try:
                # Пытаемся распарсить дату с помощью универсального парсера
                # dateutil.parser автоматически определяет формат даты
                date_parser.parse(value)
                date_count += 1
            except (ValueError, TypeError):
                # Если не получилось распарсить дату, пропускаем
                # ValueError - неправильный формат даты
                # TypeError - неподходящий тип данных
                pass
                
        # Если больше 80% значений - даты, считаем поле датой
        # Порог 80% позволяет игнорировать случайные текстовые значения
        if date_count / len(non_empty) > 0.8:
            return 'date'
            
        # По умолчанию считаем поле текстовым
        # Это происходит, если не удалось определить как число или дату
        return 'text'
        
    def sort_value(self, value: str, field_type: str) -> Union[str, float, datetime]:
        """
        Преобразование значения для корректной сортировки
        
        Этот метод преобразует строковые значения в соответствующие типы данных
        для правильной сортировки. Обрабатывает пустые значения, числовые форматы
        с запятыми, различные форматы дат и приводит текст к нижнему регистру.
        
        Args:
            value: Значение для преобразования (строка из CSV)
            field_type: Тип поля ('text', 'number', 'date')
            
        Returns:
            Преобразованное значение для сортировки:
            - text: строка в нижнем регистре или пустая строка
            - number: float число или -inf для ошибок
            - date: объект datetime или минимальная дата для ошибок
        """
        
        # Обрабатываем пустые значения (пустые строки, пробелы, None)
        if not value or value.strip() == '':
            # Для текста возвращаем пустую строку (сортируется в начало)
            # Для чисел и дат возвращаем минимальное значение (сортируется в начало)
            return '' if field_type == 'text' else float('-inf')
            
        # Убираем лишние пробелы в начале и конце строки
        # Это важно для корректного сравнения значений
        value = value.strip()
        
        if field_type == 'number':
            try:
                # Преобразуем в число, заменяя запятую на точку
                # Это нужно для европейского формата чисел (1,5 → 1.5)
                # float() автоматически обрабатывает научную нотацию (1e3)
                return float(value.replace(',', '.'))
            except ValueError:
                # В случае ошибки (нечисловые символы, неправильный формат)
                # возвращаем минимальное число для сортировки в начало
                return float('-inf')
                
        elif field_type == 'date':
            try:
                # Парсим дату с помощью универсального парсера
                # dateutil.parser автоматически определяет формат даты
                # Поддерживает: DD.MM.YYYY, YYYY-MM-DD, MM/DD/YYYY и др.
                return date_parser.parse(value)
            except (ValueError, TypeError):
                # ValueError - неправильный формат даты
                # TypeError - неподходящий тип данных
                # Возвращаем минимальную дату для сортировки в начало
                return datetime.min
        else:
            # Для текста приводим к нижнему регистру для корректной сортировки
            # Это обеспечивает одинаковую сортировку "А" и "а", "B" и "b"
            # Без этого "Z" сортировалось бы перед "a"
            return value.lower()
            
    def sort_csv_file(self, input_file: Path, output_file: Path, sort_config: Dict[str, Any]):
        """
        Сортировка CSV файла по заданным полям
        
        Этот метод выполняет основную работу по сортировке CSV файла:
        1. Читает входной файл и парсит CSV структуру
        2. Определяет типы полей для сортировки (автоматически или по конфигурации)
        3. Создает функцию сортировки с учетом типов данных
        4. Сортирует строки по заданным критериям
        5. Сохраняет результат с сохранением исходного форматирования
        
        Особенности:
        - Сохраняет исходное форматирование CSV (разделители, кавычки, экранирование)
        - Автоматически определяет типы полей при type='auto'
        - Обрабатывает пустые значения корректно для каждого типа
        - Поддерживает сортировку по нескольким полям одновременно
        
        Args:
            input_file: Путь к входному CSV файлу для обработки
            output_file: Путь для сохранения отсортированного файла
            sort_config: Конфигурация сортировки (разделитель, поля, порядок)
        """
        
        self.logger.info(f"Начинаю сортировку файла: {input_file}")
        
        try:
            # Открываем входной файл для чтения
            with open(input_file, 'r', encoding='utf-8', newline='') as f:
                # Создаем CSV reader с заданным разделителем
                reader = csv.reader(f, delimiter=sort_config['delimiter'])
                # Читаем все строки в список
                rows = list(reader)
                
            # Проверяем, что файл не пустой
            if not rows:
                self.logger.warning(f"Файл {input_file} пуст")
                return
                
            # Разделяем заголовок и данные
            header = rows[0]      # Первая строка - заголовок
            data_rows = rows[1:]  # Остальные строки - данные
            
            # Записываем отладочную информацию
            self.logger.debug(f"Заголовок: {header}")
            self.logger.debug(f"Количество строк данных: {len(data_rows)}")
            
            # Определяем типы полей для сортировки
            field_types = {}
            for field_config in self.common_sort_fields:
                field_name = field_config['name']
                
                if field_config['type'] == 'auto':
                    # Автоматически определяем тип поля
                    column_index = header.index(field_name)  # Индекс колонки
                    # Берем первые 100 строк для определения типа
                    sample_values = [row[column_index] for row in data_rows[:100]]
                    field_types[field_name] = self.detect_field_type(sample_values)
                    self.logger.info(f"Автоопределение типа поля '{field_name}': {field_types[field_name]}")
                else:
                    # Используем заданный тип
                    field_types[field_name] = field_config['type']
                    
            # Создаем функцию для сортировки строк
            def sort_key(row):
                key_values = []
                # Проходим по всем полям для сортировки
                for field_config in self.common_sort_fields:
                    field_name = field_config['name']
                    column_index = header.index(field_name)  # Индекс колонки
                    
                    # Получаем значение из строки (или пустую строку, если колонки нет)
                    value = row[column_index] if column_index < len(row) else ''
                    
                    # Преобразуем значение для сортировки
                    sort_value = self.sort_value(value, field_types[field_name])
                    key_values.append(sort_value)
                    
                # Возвращаем кортеж для сортировки по нескольким полям
                return tuple(key_values)
                
            # Сортируем данные по заданному ключу
            reverse = sort_config['order'] == 'desc'  # Определяем направление сортировки
            sorted_data = sorted(data_rows, key=sort_key, reverse=reverse)
            
            # Записываем информацию о сортировке
            self.logger.info(f"Данные отсортированы. Порядок: {'убывание' if reverse else 'возрастание'}")
            
            # Записываем отсортированный файл, сохраняя исходное форматирование
            with open(output_file, 'w', encoding='utf-8', newline='') as f:
                # Записываем заголовок как есть
                f.write(sort_config['delimiter'].join(header) + '\n')
                # Записываем отсортированные данные как есть
                for row in sorted_data:
                    f.write(sort_config['delimiter'].join(row) + '\n')
                
            self.logger.info(f"Отсортированный файл сохранен: {output_file}")
            
        except Exception as e:
            # В случае ошибки записываем её в лог и пробрасываем дальше
            self.logger.error(f"Ошибка при сортировке файла {input_file}: {str(e)}")
            raise
            
    def process_files(self):
        """
        Основной метод обработки всех файлов
        
        Этот метод является главным координатором процесса сортировки:
        1. Проверяет наличие полей для сортировки
        2. Проходит по всем файлам из конфигурации
        3. Для каждого файла вызывает сортировку
        4. Обрабатывает ошибки и ведет логирование
        5. Создает выходные файлы с суффиксом _SORT
        
        Логика работы:
        - Проверяет существование входных файлов
        - Создает имена выходных файлов автоматически
        - Обрабатывает каждый файл независимо (ошибка в одном не влияет на другие)
        - Записывает подробные логи о процессе обработки
        
        Выходные файлы:
        - Сохраняются в папке OUTPUT
        - Имеют суффикс _SORT (например: file.csv → file_SORT.csv)
        - Сохраняют исходное форматирование CSV
        """
        
        self.logger.info("Начинаю обработку CSV файлов")
        
        # Проверяем, что есть поля для сортировки
        if not self.common_sort_fields:
            self.logger.error("Нет общих полей для сортировки. Обработка прервана.")
            return
            
        # Формируем пути к папкам
        base_path = Path(self.config['base_path'])
        input_dir = base_path / self.config['input_subfolder']
        output_dir = base_path / self.config['output_subfolder']
        
        # Проходим по всем файлам из конфигурации
        for filename in self.config['input_files']:
            # Формируем путь к входному файлу
            input_file = input_dir / f"{filename}.csv"
            
            # Проверяем существование входного файла
            if not input_file.exists():
                self.logger.error(f"Входной файл не найден: {input_file}")
                continue
                
            # Формируем имя выходного файла (добавляем _SORT)
            output_filename = f"{filename}_SORT.csv"
            output_file = output_dir / output_filename
            
            self.logger.info(f"Обрабатываю файл: {filename}")
            
            try:
                # Сортируем файл
                self.sort_csv_file(input_file, output_file, self.config['sort_config'])
                self.logger.info(f"Файл {filename} успешно обработан")
            except Exception as e:
                # В случае ошибки записываем её в лог
                self.logger.error(f"Не удалось обработать файл {filename}: {str(e)}")
                
        self.logger.info("Обработка завершена")


# =============================================================================
# ГЛАВНАЯ ФУНКЦИЯ ПРОГРАММЫ
# =============================================================================
# В этом разделе находится главная функция main(), которая является точкой входа
# в программу. Она координирует весь процесс работы:
# 
# 1. Создание конфигурации из констант
# 2. Инициализация экземпляра класса CSVSorter
# 3. Запуск процесса обработки всех файлов
# 
# Структура функции:
# - Сбор конфигурации из констант, определенных выше
# - Создание и настройка сортировщика
# - Запуск обработки файлов
# - Обработка результатов и ошибок

def main():
    """
    Главная функция программы
    
    Эта функция является точкой входа в программу и выполняет:
    1. Создание конфигурационного словаря из констант
    2. Инициализацию экземпляра класса CSVSorter
    3. Запуск процесса обработки всех файлов
    
    Конфигурация собирается из констант, определенных в начале файла:
    - BASE_PATH: базовая рабочая директория
    - INPUT_SUBFOLDER: папка для входных файлов
    - OUTPUT_SUBFOLDER: папка для результатов
    - LOGS_SUBFOLDER: папка для логов
    - LOG_FILENAME: имя файла логов
    - INPUT_FILES: список файлов для обработки
    - SORT_CONFIG: настройки сортировки
    
    После создания сортировщика автоматически:
    - Создаются необходимые папки
    - Настраивается система логирования
    - Анализируются входные файлы
    - Выполняется сортировка всех файлов
    """
    
    # Конфигурация программы - все параметры заданы здесь
    # Этот словарь передается в класс CSVSorter для настройки его работы
    # 
    # Структура конфигурации:
    # - Пути к папкам для работы с файлами
    # - Настройки логирования и именования
    # - Список файлов для обработки
    # - Параметры сортировки данных
    config = {
        'base_path': BASE_PATH,                    # Базовая рабочая папка (где создаются INPUT/OUTPUT/LOGS)
        'input_subfolder': INPUT_SUBFOLDER,        # Подпапка для входных файлов (по умолчанию: INPUT)
        'output_subfolder': OUTPUT_SUBFOLDER,      # Подпапка для выходных файлов (по умолчанию: OUTPUT)
        'logs_subfolder': LOGS_SUBFOLDER,          # Подпапка для логов (по умолчанию: LOGS)
        'log_filename': LOG_FILENAME,              # Имя файла логов без расширения (по умолчанию: csv_sorter)
        'input_files': INPUT_FILES,                # Список имен файлов без расширения .csv для обработки
        'sort_config': SORT_CONFIG                 # Конфигурация сортировки (разделитель, поля, порядок)
    }
    
    # Проверка корректности конфигурации:
    # - Все пути должны быть корректными
    # - Список файлов не должен быть пустым
    # - Конфигурация сортировки должна содержать необходимые поля
    
    # Создаем экземпляр сортировщика с заданной конфигурацией
    # При создании объекта автоматически:
    # - Настраивается система логирования
    # - Создаются необходимые папки (INPUT, OUTPUT, LOGS)
    # - Анализируются входные файлы для определения общих полей
    # 
    # Конструктор класса CSVSorter выполняет:
    # 1. Сохранение конфигурации в экземпляре
    # 2. Настройку логирования (файл + консоль)
    # 3. Создание рабочей структуры папок
    # 4. Анализ входных файлов для определения общих полей
    sorter = CSVSorter(config)
    
    # Запускаем процесс обработки всех файлов
    # Метод process_files() последовательно обрабатывает каждый файл:
    # - Читает CSV структуру и заголовки
    # - Определяет типы полей (автоматически или по конфигурации)
    # - Сортирует данные по заданным критериям
    # - Сохраняет результаты с суффиксом _SORT
    # 
    # Обработка файлов происходит независимо:
    # - Ошибка в одном файле не влияет на обработку других
    # - Каждый файл логируется отдельно
    # - Результаты сохраняются по мере готовности
    sorter.process_files()


# =============================================================================
# ТОЧКА ВХОДА В ПРОГРАММУ
# =============================================================================
# Этот блок обеспечивает, что функция main() выполняется только при прямом запуске файла
# Если файл импортируется как модуль, main() не выполняется
# 
# Принцип работы:
# - При прямом запуске: python main.py → main() выполняется
# - При импорте: import main → main() НЕ выполняется
# 
# Это стандартный Python паттерн для скриптов, который позволяет:
# - Использовать файл как исполняемый скрипт
# - Импортировать функции и классы в другие модули
# - Контролировать, когда выполняется основной код

if __name__ == "__main__":
    # Запускаем главную функцию программы
    # Это стандартный Python паттерн для скриптов
    # 
    # Условие __name__ == "__main__" проверяет:
    # - Запущен ли файл напрямую (python main.py)
    # - Или импортирован как модуль (import main)
    # 
    # При прямом запуске:
    # - __name__ = "__main__" → main() выполняется
    # - Программа начинает работу
    # 
    # При импорте:
    # - __name__ = "main" → main() НЕ выполняется
    # - Можно использовать классы и функции
    main()
